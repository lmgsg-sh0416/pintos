#include "filesys/cache.h"
#include "threads/malloc.h"
#include "filesys/filesys.h"

static struct list buffer_cache;
static struct lock cache_lock;

static size_t cache_entries;

void
init_buffer_cache ()
{
  list_init (&buffer_cache);
  lock_init (&cache_lock);
  cache_entries = 0;
}

uint8_t*
search_buffer_cache (block_sector_t sector)
{
  struct cache *entry;
  bool hit = false;

  lock_acquire (&cache_lock);
  if (cache_entries != 0)
    {
      size_t i;
      struct list_elem *e = list_begin (&buffer_cache);

      for (i = 0; ; i++, e = list_next (e))
        {
          entry = list_entry (e, struct cache, elem);

          if (entry->sector == sector)
            {
              hit = true;
              list_remove (&entry->elem);
              break;
            }
          
          if (i == cache_entries - 1) {
            entry = NULL;
            break;
          }
        }
    }

  if (!hit)
    {
      if (cache_entries == CACHE_SIZE_LIMIT)
        {
          struct cache *evicted = list_entry (list_pop_front (&buffer_cache), struct cache, elem);
          
          if (evicted->dirty)
            block_write (fs_device, evicted->sector, evicted->data);

          entry->data = evicted->data;
          entry = evicted;
        }
      else
        {
          entry = malloc (sizeof *entry);
          entry->data = malloc (BLOCK_SECTOR_SIZE);
          cache_entries++;
        }

      entry->dirty = false;
      entry->sector = sector;

      block_read (fs_device, entry->sector, entry->data);
    }

  list_push_back (&buffer_cache, &entry->elem);
  lock_release (&cache_lock);
  return entry->data;
}
