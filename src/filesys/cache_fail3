#include "filesys/cache.h"
#include <string.h>
#include "devices/timer.h"
#include "threads/thread.h"
#include "threads/malloc.h"
#include "filesys/filesys.h"

static bool search_buffer_cache (block_sector_t sector, struct cache **entry);
static void periodic_flush (void);

static struct list buffer_cache;
static struct lock cache_lock;

static size_t num_cache;

void
init_buffer_cache ()
{
  list_init (&buffer_cache);
  lock_init (&cache_lock);
  num_cache = 0;

  thread_create ("periodic_flush", PRI_MIN, periodic_flush, NULL);
}

void 
read_buffer_cache (block_sector_t sector, uint8_t *buffer,
                   off_t bytes_read, int sector_ofs, int chunk_size)
{
  struct cache *entry = NULL;

  lock_acquire (&cache_lock);
  if (!search_buffer_cache (sector, &entry))
    {
      if (num_cache == CACHE_SIZE_LIMIT)
        {
          ASSERT (!list_empty (&buffer_cache));
          struct cache *evicted = list_entry (list_pop_front (&buffer_cache), struct cache, elem);

          if (evicted->dirty)
            {
              block_write (fs_device, evicted->sector, evicted->data);
              evicted->dirty = false;
            }
         
          free (evicted->data);
          free (evicted);
          num_cache--;
        }

      entry = malloc (sizeof *entry);
      entry->data = malloc (BLOCK_SECTOR_SIZE);
      entry->sector = sector;
      entry->dirty = false;
      num_cache++;

      block_read (fs_device, entry->sector, entry->data);
      
      list_push_back (&buffer_cache, &entry->elem);
    }

  memcpy (buffer + bytes_read, entry->data + sector_ofs, chunk_size);

  list_remove (&entry->elem);
  list_push_back (&buffer_cache, &entry->elem);
  lock_release (&cache_lock);
}

void
write_buffer_cache (block_sector_t sector, const uint8_t *buffer,
                    off_t bytes_written, int sector_ofs, int chunk_size)
{
  struct cache *entry = NULL;

  lock_acquire (&cache_lock);
  if (!search_buffer_cache (sector, &entry))
    {
      if (num_cache == CACHE_SIZE_LIMIT)
        {
          struct cache *evicted = list_entry (list_pop_front (&buffer_cache), struct cache, elem);

          if (evicted->dirty)
            {
              block_write (fs_device, evicted->sector, evicted->data);
              evicted->dirty = false;
            }

          free (evicted->data);
          free (evicted);
          num_cache--;
        }

      entry = malloc (sizeof *entry);
      entry->data = malloc (BLOCK_SECTOR_SIZE);
      entry->sector = sector;
      entry->dirty = false;
      num_cache++;

      if ((sector_ofs == 0 && chunk_size == BLOCK_SECTOR_SIZE) ||
          (sector_ofs > 0 || chunk_size < BLOCK_SECTOR_SIZE - sector_ofs))
        block_read (fs_device, entry->sector, entry->data);
      else
        memset (entry->data, 0, BLOCK_SECTOR_SIZE);
      
      list_push_back (&buffer_cache, &entry->elem);
    }

  memcpy (entry->data + sector_ofs, buffer + bytes_written, chunk_size);
  entry->dirty = true;

  list_remove (&entry->elem);
  list_push_back (&buffer_cache, &entry->elem);
  lock_release (&cache_lock);
}

void
flush_buffer_cache ()
{
  size_t i;
  struct list_elem *e;
  
  if (num_cache == 0)
    return;

  lock_acquire (&cache_lock);
  for (i = 0, e = list_begin (&buffer_cache); ; i++, e = list_next (e))
    {
      struct cache *temp = list_entry (e, struct cache, elem);

      if (temp->dirty)
        {
          block_write (fs_device, temp->sector, temp->data);
          temp->dirty = false;
        }

      if (i == num_cache - 1)
        break;
    }
  lock_release (&cache_lock);
}

static bool
search_buffer_cache (block_sector_t sector, struct cache **entry)
{
  size_t i;
  struct list_elem *e;

  if (num_cache == 0)
    {
      *entry = NULL;
      return false;
    }

  for (i = 0, e = list_begin (&buffer_cache); ; i++, e = list_next (e))
    {
      struct cache *temp = list_entry (e, struct cache, elem);

      if (temp->sector == sector)
        {
          *entry = temp;
          return true;
        }
      
      if (i == num_cache - 1)
        break;
    }

  *entry = NULL;
  return false;
}

static void
periodic_flush ()
{
  for ( ; ; )
    {
      timer_sleep (FLUSH_FREQ);
      flush_buffer_cache ();
    }
}
