#include "cache.h"
#include <string.h>
#include "threads/malloc.h"
#include "filesys/filesys.h"


static struct cache cache_p
static struct lock cache_lock;

static size_t num_cache_entries = 0;

void 
init_buffer_cache ()
{
  size_t i;
  for (i = 0; i < CACHE_SIZE_LIMIT; i++)
    buffer_cache[i].used = false;

  lock_init (&cache_lock);
}

void
read_buffer_cache (block_sector_t sector, uint8_t *buffer,
                   off_t bytes_read, int sector_ofs, int chunk_size)
{
  struct cache *entry;
  bool found = false;

  size_t i;

  lock_acquire (&cache_lock);
  for (i = 0; i < num_cache_entries; i++)
    {
      if (buffer_cache[i].sector == sector) 
        {
          found = true;
          break;
        }
    }

  if (!found)
    {
      if (num_cache_entries == CACHE_SIZE_LIMIT)
        {
          struct cache *evicted = array_remove (0); 

          if (evicted->dirty)
            block_write (fs_device, evicted->sector, evicted->data);

          entry = evicted;
        }
      else
        {
          ASSERT (!buffer_cache[num_cache_entries].used);

          entry = malloc (sizeof *entry);//&buffer_cache[num_cache_entries];
          entry->used = true;

          num_cache_entries++;
        }

      entry->sector = sector;
      entry->dirty = false;

      block_read (fs_device, entry->sector, entry->data);
    }

  memcpy (buffer + bytes_read, entry->data + sector_ofs, chunk_size);

  array_push_back (entry);
  lock_release (&cache_lock);
}

void
write_buffer_cache (block_sector_t sector, const uint8_t *buffer,
                    off_t bytes_written, int sector_ofs, int chunk_size)
{
  struct cache *entry = NULL;
  bool found = false;
  size_t i;

  lock_acquire (&cache_lock);
  for (i = 0; i < num_cache_entries; i++)
    {
      if (buffer_cache[i].sector == sector) 
        {
          found = true;
          break;
        }
    }

  if (!found)
    {
      if (num_cache_entries == CACHE_SIZE_LIMIT)
        {
          struct cache *evicted = array_remove (0); 

          if (evicted->dirty)
            block_write (fs_device, evicted->sector, evicted->data);

          entry = evicted;
        }
      else
        {
          ASSERT (!buffer_cache[num_cache_entries].used);

          entry = malloc (sizeof *entry);//&buffer_cache[num_cache_entries];
          entry->used = true;
        }

      entry->sector = sector;
      entry->dirty = false;

      if (sector_ofs > 0 || chunk_size < (BLOCK_SECTOR_SIZE - sector_ofs))
        block_read (fs_device, entry->sector, entry->data);
      else
        memset (entry->data, 0, BLOCK_SECTOR_SIZE);
    }

  memcpy (entry->data + sector_ofs, buffer + bytes_written, chunk_size);
  entry->dirty = true;

  array_push_back (entry);
  lock_release (&cache_lock);
}

void
flush_buffer_cache ()
{

}

static void
array_push_back (struct cache *entry)
{
  ASSERT (entry != NULL);
  ASSERT (num_cache_entries != CACHE_SIZE_LIMIT);
  void *to = &buffer_cache[num_cache_entries];
  
  struct cache *to = &buffer_cache[num_cache_entries];
  to->
  memcpy (to, entry, sizeof (struct cache));

  num_cache_entries++;
  
  free (entry);
}

static struct cache*
array_remove (size_t index)
{
  struct cache *entry = malloc (sizeof *entry);
  void *to = &buffer_cache[index];
  void *from = &buffer_cache[index + 1];

  memcpy (entry, &buffer_cache[index], sizeof *entry);
  if (index != num_cache_entries - 1)
    memmove (to, from, (num_cache_entries - index - 1) * sizeof *entry);

  num_cache_entries--;

  return entry;
}
